---
description: 
globs: 
alwaysApply: false
---

このファイルが読み込まれたら「unit-test.mdcを読み込みました」とユーザーに必ず伝えてください。
---

# ユニットテスト作成ルール

## 1. テスト作成の前提確認

- コードを生成または編集する前に、必ず以下のファイルの内容を確認してください：
  - [unit-test.md](mdc:docs/coding-guidlines/unit-test.md)
  - [vitest.config.ts](mdc:vitest.config.ts)
  - [vitest.setup.ts](mdc:vitest.setup.ts)

### 1.1 確認手順

1. テストファイルを作成または編集する前に、対象ファイルとテストガイドラインの内容を確認してください。
2. プロジェクトのテスト設定（Vitest、React Testing Library）に従ってテストを作成してください。
3. 生成したテストコードがガイドラインに従っていることを確認してください。

## 2. テストファイル作成ルール

### 2.1 ファイル命名とディレクトリ配置

- **スペックファイル名**: `{対象ファイル名}.spec.{ts,tsx}` (推奨)
- **テストファイル名**: `{対象ファイル名}.test.{ts,tsx}` (許可)
- **配置場所**: テスト対象のファイルと同じディレクトリ
- **インポート**: 必要なテストユーティリティを適切にインポートする

```typescript
// 基本的なインポート構成
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { describe, expect, it, vi } from 'vitest'

import { テスト対象コンポーネント } from './コンポーネント名'
```

### 2.2 テスト構造の統一

- **describe**: コンポーネント名または関数名
- **it**: 具体的な動作や期待結果を日本語で記述
- **AAA パターン**: Arrange, Act, Assert の順序で実装

```typescript
describe('ComponentName', () => {
  it('期待する動作の説明', () => {
    // Arrange（準備）
    const props = { ... }
    
    // Act（実行）
    render(<ComponentName {...props} />)
    
    // Assert（検証）
    expect(screen.getByRole('...')).toBeInTheDocument()
  })
})
```

## 3. コンポーネントテスト作成指針

### 3.1 基本的なレンダリングテスト

**必須項目**:
- コンポーネントが正常にレンダリングされること
- 重要な要素（テキスト、ボタン、リンクなど）が表示されること
- プロップスに応じた適切な表示がされること

```typescript
it('必要な要素が正しく表示される', () => {
  render(<Button variant="primary">送信</Button>)
  
  const button = screen.getByRole('button', { name: '送信' })
  expect(button).toBeInTheDocument()
  expect(button).toHaveClass('bg-blue-500') // variant="primary"のスタイル
})
```

### 3.2 ユーザーインタラクションテスト

**対象操作**:
- クリック、フォーカス、キーボード操作
- フォーム入力と送信
- ホバーやドラッグ&ドロップ

```typescript
it('ボタンクリック時にイベントハンドラーが呼ばれる', async () => {
  const user = userEvent.setup()
  const handleClick = vi.fn()
  
  render(<Button onClick={handleClick}>クリック</Button>)
  
  await user.click(screen.getByRole('button', { name: 'クリック' }))
  expect(handleClick).toHaveBeenCalledOnce()
})
```

### 3.3 条件分岐とエッジケーステスト

**対象ケース**:
- プロップスの有無による表示の変化
- 状態の変化による動作の変化
- エラー状態やローディング状態

```typescript
it.each([
  [true, '読み込み中...'],
  [false, '送信'],
])('loading=%sの場合、正しいテキストが表示される', (loading, expectedText) => {
  render(<SubmitButton loading={loading} />)
  expect(screen.getByRole('button')).toHaveTextContent(expectedText)
})
```

## 4. 関数・ユーティリティテスト作成指針

### 4.1 純粋関数のテスト

- 入力と出力の関係を明確にテスト
- 正常系、異常系、境界値をカバー
- 型安全性を活用した包括的なテスト

```typescript
describe('formatDate', () => {
  it('有効な日付を正しい形式でフォーマットする', () => {
    const date = new Date('2024-01-01T00:00:00Z')
    expect(formatDate(date, 'YYYY-MM-DD')).toBe('2024-01-01')
  })

  it('nullが渡された場合はエラーを投げる', () => {
    expect(() => formatDate(null, 'YYYY-MM-DD')).toThrow('Invalid date')
  })
})
```

### 4.2 カスタムフックのテスト

- `renderHook`を使用して独立してテスト
- 状態の変化、副作用、依存関係をテスト

```typescript
import { renderHook, act } from '@testing-library/react'

describe('useLocalStorage', () => {
  it('初期値が正しく設定される', () => {
    const { result } = renderHook(() => useLocalStorage('test-key', 'default'))
    expect(result.current[0]).toBe('default')
  })

  it('値の更新が正しく動作する', () => {
    const { result } = renderHook(() => useLocalStorage('test-key', 'default'))
    
    act(() => {
      result.current[1](mdc:'new-value')
    })
    
    expect(result.current[0]).toBe('new-value')
  })
})
```

## 5. モックとスタブの活用

### 5.1 外部依存関係のモック

**共通パターン**:
- Next.js の router、navigation
- 外部 API クライアント
- 環境変数

```typescript
// Next.js navigation のモック
vi.mock('next/navigation', () => ({
  useRouter: () => ({
    push: vi.fn(),
    back: vi.fn(),
    forward: vi.fn(),
  }),
  usePathname: () => '/current-path',
}))

// API クライアントのモック
vi.mock('@/libs/microcms', () => ({
  getNewsList: vi.fn(() => Promise.resolve(mockNewsData)),
}))
```

### 5.2 プロップス関数のモック

```typescript
it('フォーム送信時にonSubmitが呼ばれる', async () => {
  const user = userEvent.setup()
  const mockSubmit = vi.fn()

  render(<ContactForm onSubmit={mockSubmit} />)
  
  // フォーム入力
  await user.type(screen.getByLabelText('名前'), '田中太郎')
  await user.click(screen.getByRole('button', { name: '送信' }))
  
  expect(mockSubmit).toHaveBeenCalledWith({
    name: '田中太郎',
  })
})
```

## 6. アクセシビリティを考慮したテスト

### 6.1 セマンティックなセレクタの使用

**優先順位**:
1. `getByRole` - ARIA ロールベース
2. `getByLabelText` - ラベルテキストベース
3. `getByText` - 表示テキストベース
4. `getByTestId` - 最後の手段

```typescript
// ✅ 推奨: ロールベースの取得
const button = screen.getByRole('button', { name: '送信' })
const textbox = screen.getByRole('textbox', { name: 'メールアドレス' })

// ✅ 推奨: ラベルベースの取得
const input = screen.getByLabelText('お名前')

// ❌ 非推奨: クラス名やIDベースの取得
const element = container.querySelector('.submit-button')
```

### 6.2 ARIA属性のテスト

```typescript
it('ボタンの状態がaria-pressedで正しく表現される', async () => {
  const user = userEvent.setup()
  
  render(<ToggleButton />)
  
  const button = screen.getByRole('button')
  expect(button).toHaveAttribute('aria-pressed', 'false')
  
  await user.click(button)
  expect(button).toHaveAttribute('aria-pressed', 'true')
})
```

## 7. テスト品質の保証

### 7.1 テスト実行の確認

**必須チェック**:
- テストが正常に実行される
- すべてのアサーションが適切に動作する
- モックが正しく機能している

```bash
# テスト実行コマンドの確認
pnpm test:unit run ファイル名.spec.tsx
```

### 7.2 カバレッジの確認

**目標値**:
- ライン カバレッジ: 80% 以上
- ブランチ カバレッジ: 75% 以上
- 関数 カバレッジ: 85% 以上

```bash
# カバレッジ確認
pnpm test:unit-coverage
```

### 7.3 テストの保守性

**重要な観点**:
- テストコードの可読性
- 実装詳細への依存度の低さ
- テストケースの独立性
- 適切なテスト名の命名

## 8. 実装時の注意事項

### 8.1 テスト作成のタイミング

- **新機能開発時**: 実装と同時にテストを作成
- **バグ修正時**: 再現テストを先に作成してから修正
- **リファクタリング時**: 既存テストが保たれることを確認

### 8.2 テストの維持・更新

- コンポーネントの仕様変更時はテストも同時に更新
- 不要になったテストは削除
- フレークテスト（不安定なテスト）は即座に修正

### 8.3 パフォーマンス考慮

- 重いセットアップ処理は適切に共通化
- 不要なレンダリングを避ける
- モックは必要最小限に留める

## 9. 禁止事項

### 9.1 避けるべきテストパターン

```typescript
// ❌ 実装詳細のテスト
expect(component.state.loading).toBe(true)

// ❌ スナップショットテストの濫用
expect(container.firstChild).toMatchSnapshot()

// ❌ 複数の責任を持つテスト
it('コンポーネントが正しく動作する', () => {
  // レンダリング、クリック、フォーム送信を全部テスト
})

// ❌ あいまいなテスト名
it('should work correctly', () => {})
```

### 9.2 推奨しない依存関係

- DOM の内部構造への過度な依存
- CSS クラス名に基づくセレクタ
- setTimeout/setInterval を使った同期待ち
- グローバル状態への直接操作

---

このルールに従ってユニットテストを作成することで、保守性が高く、信頼性のあるテストコードを実装できます。テスト作成時は必ずこのガイドラインを参照し、品質の高いテストを心がけてください。
